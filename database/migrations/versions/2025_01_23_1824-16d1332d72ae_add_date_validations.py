"""add date validations

Revision ID: 16d1332d72ae
Revises: 78dc89b6afaa
Create Date: 2025-01-23 18:24:50.475347

"""
from typing import Sequence, Union

import geoalchemy2
import sqlalchemy as sa
from alembic import op
from alembic_utils.pg_function import PGFunction
from alembic_utils.pg_trigger import PGTrigger
from sqlalchemy import text as sql_text

# revision identifiers, used by Alembic.
revision: str = "16d1332d72ae"
down_revision: Union[str, None] = "78dc89b6afaa"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    hame_trgfunc_lifecycle_date_validate_dates = PGFunction(
        schema="hame",
        signature="trgfunc_lifecycle_date_validate_dates()",
        definition="RETURNS TRIGGER AS $$\n    BEGIN\n        IF (\n            NEW.starting_at IS NOT NULL AND\n            NEW.ending_at IS NOT NULL AND\n            NEW.starting_at > NEW.ending_at\n        ) IS TRUE\n        THEN\n            RAISE EXCEPTION 'Status starting date % after ending date %',\n                NEW.starting_at, NEW.ending_at\n                USING HINT = 'Status ending date must be after starting date.';\n        END IF;\n        RETURN NEW;\n    END;\n    $$ language 'plpgsql'",
    )
    op.create_entity(hame_trgfunc_lifecycle_date_validate_dates)

    hame_trgfunc_event_date_validate_dates = PGFunction(
        schema="hame",
        signature="trgfunc_event_date_validate_dates()",
        definition="RETURNS TRIGGER AS $$\n    BEGIN\n        IF (\n            NEW.starting_at IS NOT NULL AND\n            NEW.ending_at IS NOT NULL AND\n            NEW.starting_at > NEW.ending_at\n        ) IS TRUE\n        THEN\n            RAISE EXCEPTION 'Event starting date % after ending date %',\n                NEW.starting_at, NEW.ending_at\n                USING HINT = 'Event ending date must be after starting date.';\n        END IF;\n        RETURN NEW;\n    END;\n    $$ language 'plpgsql'",
    )
    op.create_entity(hame_trgfunc_event_date_validate_dates)

    hame_trgfunc_event_date_validate_inside_status_date = PGFunction(
        schema="hame",
        signature="trgfunc_event_date_validate_inside_status_date()",
        definition="RETURNS TRIGGER AS $$\n    DECLARE\n        status_starting_at TIMESTAMP WITH TIME ZONE;\n        status_ending_at TIMESTAMP WITH TIME ZONE;\n    BEGIN\n        SELECT starting_at, ending_at INTO status_starting_at, status_ending_at\n        FROM hame.lifecycle_date\n        WHERE NEW.lifecycle_date_id = hame.lifecycle_date.id;\n        IF (\n            -- Does the event start before status starts?\n            (\n             NEW.starting_at < status_starting_at\n            ) OR\n            -- Missing event ending date means event is instantaneous. Only\n            -- events with ending date have a duration. Both must have ending\n            -- date specified to check if event ends after status ends.\n            (\n             NEW.ending_at IS NOT NULL AND status_ending_at IS NOT NULL AND\n             NEW.ending_at > status_ending_at\n            )\n        ) IS TRUE\n        THEN\n            RAISE EXCEPTION 'Event dates % - % outside status dates % - %',\n                NEW.starting_at, NEW.ending_at, status_starting_at, status_ending_at\n                USING HINT = 'Event cannot be outside lifecycle status dates.';\n        END IF;\n        RETURN NEW;\n    END;\n    $$ language 'plpgsql'",
    )
    op.create_entity(hame_trgfunc_event_date_validate_inside_status_date)

    hame_trgfunc_event_date_validate_type = PGFunction(
        schema="hame",
        signature="trgfunc_event_date_validate_type()",
        definition="RETURNS TRIGGER AS $$\n    DECLARE\n        status_id UUID;\n        association_id UUID;\n    BEGIN\n        SELECT lifecycle_status_id INTO status_id\n        FROM\n            hame.lifecycle_date\n        WHERE\n            NEW.lifecycle_date_id = lifecycle_date.id;\n        SELECT id INTO association_id\n        FROM\n            codes.allowed_events\n        WHERE\n            lifecycle_status_id = status_id AND (\n                (NEW.decision_id IS NOT NULL AND\n                 name_of_plan_case_decision_id = NEW.decision_id) OR\n                (NEW.processing_event_id IS NOT NULL AND\n                 type_of_processing_event_id = NEW.processing_event_id) OR\n                (NEW.interaction_event_id IS NOT NULL AND\n                 type_of_interaction_event_id = NEW.interaction_event_id)\n            );\n        IF association_id IS NULL\n        THEN\n            RAISE EXCEPTION 'Wrong event type for status'\n            USING HINT = 'This event type cannot be added to this lifecycle status.';\n        END IF;\n        RETURN NEW;\n    END;\n    $$ language 'plpgsql'",
    )
    op.create_entity(hame_trgfunc_event_date_validate_type)

    hame_lifecycle_date_trg_lifecycle_date_validate_dates = PGTrigger(
        schema="hame",
        signature="trg_lifecycle_date_validate_dates",
        on_entity="hame.lifecycle_date",
        is_constraint=False,
        definition="BEFORE INSERT OR UPDATE ON lifecycle_date\n        FOR EACH ROW\n        EXECUTE FUNCTION hame.trgfunc_lifecycle_date_validate_dates()",
    )
    op.create_entity(hame_lifecycle_date_trg_lifecycle_date_validate_dates)

    hame_event_date_trg_event_date_validate_dates = PGTrigger(
        schema="hame",
        signature="trg_event_date_validate_dates",
        on_entity="hame.event_date",
        is_constraint=False,
        definition="BEFORE INSERT OR UPDATE ON event_date\n        FOR EACH ROW\n        EXECUTE FUNCTION hame.trgfunc_event_date_validate_dates()",
    )
    op.create_entity(hame_event_date_trg_event_date_validate_dates)

    hame_event_date_trg_event_date_validate_inside_status_date = PGTrigger(
        schema="hame",
        signature="trg_event_date_validate_inside_status_date",
        on_entity="hame.event_date",
        is_constraint=False,
        definition="BEFORE INSERT OR UPDATE ON event_date\n        FOR EACH ROW\n        EXECUTE FUNCTION hame.trgfunc_event_date_validate_inside_status_date()",
    )
    op.create_entity(hame_event_date_trg_event_date_validate_inside_status_date)

    hame_event_date_trg_event_date_validate_type = PGTrigger(
        schema="hame",
        signature="trg_event_date_validate_type",
        on_entity="hame.event_date",
        is_constraint=False,
        definition="BEFORE INSERT OR UPDATE ON event_date\n        FOR EACH ROW\n        EXECUTE FUNCTION hame.trgfunc_event_date_validate_type()",
    )
    op.create_entity(hame_event_date_trg_event_date_validate_type)

    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    hame_event_date_trg_event_date_validate_type = PGTrigger(
        schema="hame",
        signature="trg_event_date_validate_type",
        on_entity="hame.event_date",
        is_constraint=False,
        definition="BEFORE INSERT OR UPDATE ON event_date\n        FOR EACH ROW\n        EXECUTE FUNCTION hame.trgfunc_event_date_validate_type()",
    )
    op.drop_entity(hame_event_date_trg_event_date_validate_type)

    hame_event_date_trg_event_date_validate_inside_status_date = PGTrigger(
        schema="hame",
        signature="trg_event_date_validate_inside_status_date",
        on_entity="hame.event_date",
        is_constraint=False,
        definition="BEFORE INSERT OR UPDATE ON event_date\n        FOR EACH ROW\n        EXECUTE FUNCTION hame.trgfunc_event_date_validate_inside_status_date()",
    )
    op.drop_entity(hame_event_date_trg_event_date_validate_inside_status_date)

    hame_event_date_trg_event_date_validate_dates = PGTrigger(
        schema="hame",
        signature="trg_event_date_validate_dates",
        on_entity="hame.event_date",
        is_constraint=False,
        definition="BEFORE INSERT OR UPDATE ON event_date\n        FOR EACH ROW\n        EXECUTE FUNCTION hame.trgfunc_event_date_validate_dates()",
    )
    op.drop_entity(hame_event_date_trg_event_date_validate_dates)

    hame_lifecycle_date_trg_lifecycle_date_validate_dates = PGTrigger(
        schema="hame",
        signature="trg_lifecycle_date_validate_dates",
        on_entity="hame.lifecycle_date",
        is_constraint=False,
        definition="BEFORE INSERT OR UPDATE ON lifecycle_date\n        FOR EACH ROW\n        EXECUTE FUNCTION hame.trgfunc_lifecycle_date_validate_dates()",
    )
    op.drop_entity(hame_lifecycle_date_trg_lifecycle_date_validate_dates)

    hame_trgfunc_event_date_validate_type = PGFunction(
        schema="hame",
        signature="trgfunc_event_date_validate_type()",
        definition="RETURNS TRIGGER AS $$\n    DECLARE\n        status_id UUID;\n        association_id UUID;\n    BEGIN\n        SELECT lifecycle_status_id INTO status_id\n        FROM\n            hame.lifecycle_date\n        WHERE\n            NEW.lifecycle_date_id = lifecycle_date.id;\n        SELECT id INTO association_id\n        FROM\n            codes.allowed_events\n        WHERE\n            lifecycle_status_id = status_id AND (\n                (NEW.decision_id IS NOT NULL AND\n                 name_of_plan_case_decision_id = NEW.decision_id) OR\n                (NEW.processing_event_id IS NOT NULL AND\n                 type_of_processing_event_id = NEW.processing_event_id) OR\n                (NEW.interaction_event_id IS NOT NULL AND\n                 type_of_interaction_event_id = NEW.interaction_event_id)\n            );\n        IF association_id IS NULL\n        THEN\n            RAISE EXCEPTION 'Wrong event type for status'\n            USING HINT = 'This event type cannot be added to this lifecycle status.';\n        END IF;\n        RETURN NEW;\n    END;\n    $$ language 'plpgsql'",
    )
    op.drop_entity(hame_trgfunc_event_date_validate_type)

    hame_trgfunc_event_date_validate_inside_status_date = PGFunction(
        schema="hame",
        signature="trgfunc_event_date_validate_inside_status_date()",
        definition="RETURNS TRIGGER AS $$\n    DECLARE\n        status_starting_at TIMESTAMP WITH TIME ZONE;\n        status_ending_at TIMESTAMP WITH TIME ZONE;\n    BEGIN\n        SELECT starting_at, ending_at INTO status_starting_at, status_ending_at\n        FROM hame.lifecycle_date\n        WHERE NEW.lifecycle_date_id = hame.lifecycle_date.id;\n        IF (\n            -- Does the event start before status starts?\n            (\n             NEW.starting_at < status_starting_at\n            ) OR\n            -- Missing event ending date means event is instantaneous. Only\n            -- events with ending date have a duration. Both must have ending\n            -- date specified to check if event ends after status ends.\n            (\n             NEW.ending_at IS NOT NULL AND status_ending_at IS NOT NULL AND\n             NEW.ending_at > status_ending_at\n            )\n        ) IS TRUE\n        THEN\n            RAISE EXCEPTION 'Event dates % - % outside status dates % - %',\n                NEW.starting_at, NEW.ending_at, status_starting_at, status_ending_at\n                USING HINT = 'Event cannot be outside lifecycle status dates.';\n        END IF;\n        RETURN NEW;\n    END;\n    $$ language 'plpgsql'",
    )
    op.drop_entity(hame_trgfunc_event_date_validate_inside_status_date)

    hame_trgfunc_event_date_validate_dates = PGFunction(
        schema="hame",
        signature="trgfunc_event_date_validate_dates()",
        definition="RETURNS TRIGGER AS $$\n    BEGIN\n        IF (\n            NEW.starting_at IS NOT NULL AND\n            NEW.ending_at IS NOT NULL AND\n            NEW.starting_at > NEW.ending_at\n        ) IS TRUE\n        THEN\n            RAISE EXCEPTION 'Event starting date % after ending date %',\n                NEW.starting_at, NEW.ending_at\n                USING HINT = 'Event ending date must be after starting date.';\n        END IF;\n        RETURN NEW;\n    END;\n    $$ language 'plpgsql'",
    )
    op.drop_entity(hame_trgfunc_event_date_validate_dates)

    hame_trgfunc_lifecycle_date_validate_dates = PGFunction(
        schema="hame",
        signature="trgfunc_lifecycle_date_validate_dates()",
        definition="RETURNS TRIGGER AS $$\n    BEGIN\n        IF (\n            NEW.starting_at IS NOT NULL AND\n            NEW.ending_at IS NOT NULL AND\n            NEW.starting_at > NEW.ending_at\n        ) IS TRUE\n        THEN\n            RAISE EXCEPTION 'Status starting date % after ending date %',\n                NEW.starting_at, NEW.ending_at\n                USING HINT = 'Status ending date must be after starting date.';\n        END IF;\n        RETURN NEW;\n    END;\n    $$ language 'plpgsql'",
    )
    op.drop_entity(hame_trgfunc_lifecycle_date_validate_dates)

    # ### end Alembic commands ###
